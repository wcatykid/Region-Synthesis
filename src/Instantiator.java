import java.util.Vector;

public class Instantiator
{
	public Instantiator() {
		initVariables();
	}

	//
	// Main instantiation routine for region synthesis
	//
	public Vector<Region> instantiate(RegionTemplate theTemplate)
	{
		Region workingRegion = new Region();

		// Begin with the origin as the bottom-left point by default
		Point bottomLeft = new Point(0, 0);
		Point topLeft = new Point(0, 0);

		// Handle vertical line
		if (theTemplate.leftIsPoint())
		{
			workingRegion.instantiateLeft(bottomLeft);
		}
		else
		{
			RandomGenerator.initialize();
			int vertical = RandomGenerator.nextInt(1, Constants.MAX_VERTICAL_SHIFT);
			topLeft = bottomLeft.plus(new Point(0, vertical));

			workingRegion.instantiateLeft(new LineSegment(bottomLeft, topLeft));
		}

		Vector<Region> regions = new Vector<Region>();  //Every possible problem generated by the method.

		RandomGenerator.initialize();

		regions = constructTopBottom(theTemplate, regions, workingRegion);
		workingRegion = generateNewWorkingRegion(theTemplate);
		
		return regions;
	}

	private Region generateNewWorkingRegion(RegionTemplate theTemplate) {
		Region workingRegion = new Region();
		// Begin with the origin as the bottom-left point by default
		Point bottomLeft = new Point(0, 0);
		Point topLeft = new Point(0, 0);
		if (theTemplate.leftIsPoint())
		{
			workingRegion.instantiateLeft(bottomLeft);
		}
		else
		{
			RandomGenerator.initialize();
			int vertical = RandomGenerator.nextInt(1, Constants.MAX_VERTICAL_SHIFT);
			topLeft = bottomLeft.plus(new Point(0, vertical));

			workingRegion.instantiateLeft(new LineSegment(bottomLeft, topLeft));
		}
		return workingRegion;
	}

	public void initVariables() {
		//so the code below doesn't have to change
		this.LIMITED_FUNCTIONS = Constants.LIMITED_FUNCTIONS;
		this.ALLOWED_FUNCTIONS = Constants.ALLOWED_FUNCTIONS;
		this.MAX_RIGHT_X = Constants.MAX_RIGHT_X;
		this.INTS_ONLY = Constants.INTS_ONLY;
		this.SAME_LENGTH_BOUNDS = Constants.SAME_LENGTH_BOUNDS;
		this.MAX_ATTEMPTS = Constants.MAX_ATTEMPTS;
	}
	//so the code below doesn't have to change
     boolean LIMITED_FUNCTIONS;    
     FunctionT[] ALLOWED_FUNCTIONS;
	 double MAX_RIGHT_X;  		
	 boolean INTS_ONLY;			
	 boolean SAME_LENGTH_BOUNDS; 
	 int MAX_ATTEMPTS;  

	public Vector<Region> constructTopBottom(RegionTemplate theTemplate, Vector<Region> regions, Region workingRegion)
	{
		Vector<Region> tempWorkingRegions = new Vector<>();

		if (workingRegion.bottom.length() < theTemplate.bottom.length()) //If the template requires another bottom, add it.
		{
			int currentBoundsInBottom = workingRegion.bottom.length() ;
			if (currentBoundsInBottom < 0) currentBoundsInBottom = 0;
			
			if (theTemplate.bottom.templateBounds.get(currentBoundsInBottom) != Bound.BoundT.VERTICAL_LINE){
				//If the template doesn't specify a function
				if (theTemplate.bottom.templateBounds.get(currentBoundsInBottom) == Bound.BoundT.FUNCTION) {
					for (int i = 0; i < (LIMITED_FUNCTIONS ? ALLOWED_FUNCTIONS.length : FunctionT.values().length); i++) {
						Region temp = workingRegion.clone();
						tempWorkingRegions.add(temp);
					}

					for (int i = 0; i < tempWorkingRegions.size(); i++) {
						Region tempWorkingRegion = tempWorkingRegions.get(i);
						
						FunctionT function;
						if (LIMITED_FUNCTIONS) {
							function = ALLOWED_FUNCTIONS[i];
						} else {
							function = FunctionT.values()[i];
						}
						BoundedFunction bottom = generateFunction(true, tempWorkingRegion, function);
						tempWorkingRegion.bottom.addBound(bottom);
					}
				} else {
					System.out.println("Generating a specific function!" );
					//If the template has a specific function
					if (tempWorkingRegions.isEmpty()) tempWorkingRegions.add(workingRegion.clone());
					Region tempWorkingRegion = tempWorkingRegions.lastElement();
					
					Bound.BoundT boundT = theTemplate.bottom.templateBounds.get(currentBoundsInBottom);
					
					BoundedFunction bottom = generateFunction(true, tempWorkingRegion, boundT.inFunctionTForm());
					tempWorkingRegion.bottom.addBound(bottom);
				}
			} else {
				//Generate vertical line
			}
		}
		
		Vector<Region> topTempWorkingRegions = new Vector<>();
		
		if (workingRegion.top.length() < theTemplate.top.length()) //If the template requires another top, add it and make sure it doesn't intersect.
		{
			int currentBoundsInTop = workingRegion.top.length();
			if (theTemplate.top.templateBounds.get(currentBoundsInTop) != Bound.BoundT.VERTICAL_LINE){
				
				if (theTemplate.top.templateBounds.get(currentBoundsInTop) == Bound.BoundT.FUNCTION) {
					
				
					int tempWorkingRegionsLength = tempWorkingRegions.size();
					if (tempWorkingRegionsLength < 1) tempWorkingRegionsLength = 1;
					for (int i = 0; i < (LIMITED_FUNCTIONS ? ALLOWED_FUNCTIONS.length : FunctionT.values().length); i++) {
						if (tempWorkingRegionsLength == 1) 
							topTempWorkingRegions.add(workingRegion.clone());
						else {
							for (int j = 0; j < tempWorkingRegionsLength; j++){
								topTempWorkingRegions.add(tempWorkingRegions.get(j).clone());
							}
						}
					}

					for (int i = 0; i < topTempWorkingRegions.size(); i++) {
						Region tempWorkingRegion = topTempWorkingRegions.get(i);

						BoundedFunction top = null;
						FunctionT function;
						if (LIMITED_FUNCTIONS) {
							function = ALLOWED_FUNCTIONS[i / ALLOWED_FUNCTIONS.length];
						} else {
							function = FunctionT.values()[i / FunctionT.values().length];
						}

						top = generateFunction(false, tempWorkingRegion, function);

						//Make sure the function works in the situation.
						if (!flipFunction(top, tempWorkingRegion))
							break;
						
						tempWorkingRegion.top.addBound(top);
					} 
				} else {
					//Specified Function
					System.out.println("Generating a specific top function!" );
					//If the template has a specific function
					if (topTempWorkingRegions.isEmpty()) {
						for (Region region : tempWorkingRegions) {
							topTempWorkingRegions.add(region.clone());
						}
					}
					
					for (Region region : topTempWorkingRegions) {
						Bound.BoundT boundT = theTemplate.top.templateBounds.get(currentBoundsInTop);
						
						BoundedFunction top = generateFunction(false, region, boundT.inFunctionTForm());
						//Make sure the function works in the situation.
						if (!flipFunction(top, region))
							break;
						region.top.addBound(top);
					}
				}
			} else {
				//Vertical Line
			}
		}

		if (topTempWorkingRegions.size() == 0) topTempWorkingRegions = tempWorkingRegions;
		//Alright, we generated the functions, now let's see what happens next. 
		for (int i = 0; i < topTempWorkingRegions.size(); i++) {
			Region tempWorkingRegion = topTempWorkingRegions.get(i);
			if (tempWorkingRegion.bottom.length() == theTemplate.bottom.length() &&
					tempWorkingRegion.top.length()	  == theTemplate.top.length()) 			//Make sure the template is satisfied with the number of functions.
			{
				if (theTemplate.rightIsVertical()) 
				{
					double bottomRightX = ((BoundedFunction)tempWorkingRegion.bottom.bounds.lastElement()).getRightX();
					double topRightX = ((BoundedFunction)tempWorkingRegion.top.bounds.lastElement()).getRightX();
					//If the rightX of the last functions in top and bottom are unequal, make them equal.  
					if (!Utilities.compareValues(topRightX, bottomRightX))
					{
						if (topRightX > bottomRightX) 
						{
							((BoundedFunction)tempWorkingRegion.bottom.bounds.lastElement()).setRightX(topRightX);
						} 
						else 
						{
							((BoundedFunction)tempWorkingRegion.top.bounds.lastElement()).setRightX(bottomRightX);
						}
					}
					//add in the right bound of the region as a vertical line.  
					tempWorkingRegion.right.bound = new LineSegment(tempWorkingRegion.bottom.bounds.lastElement().getLeftBottomPoint(), tempWorkingRegion.top.bounds.lastElement().getLeftTopPoint());
					regions.add(tempWorkingRegion);
				}
				else
				{
					////////////////////RIGHT POINT BOUND
					if (((BoundedFunction)tempWorkingRegion.top.bounds.lastElement()).getFunc() != FunctionT.HORIZONTAL_LINE && 
						((BoundedFunction)tempWorkingRegion.bottom.bounds.lastElement()).getFunc() != FunctionT.HORIZONTAL_LINE) {
						
						if (((BoundedFunction) tempWorkingRegion.top.bounds.lastElement()).getFunc() == FunctionT.LINEAR) {
							BoundedFunction top = (BoundedFunction) tempWorkingRegion.top.bounds.lastElement();
							BoundedFunction bottom = (BoundedFunction) tempWorkingRegion.bottom.bounds.lastElement();
							
							Point topLeftPoint = new Point(top.leftX, top.evaluateAtPoint(top.leftX));
							Point bottomRightPoint = new Point(bottom.rightX, bottom.evaluateAtPoint(bottom.rightX));
							
							BoundedFunction newTop = generateLineBetweenPoints(topLeftPoint, bottomRightPoint);
							tempWorkingRegion.top.bounds.remove(top);
							tempWorkingRegion.top.bounds.add(newTop);
							
							tempWorkingRegion.right.bound = new PointBound(bottomRightPoint);
							regions.add(tempWorkingRegion);
						} else if (((BoundedFunction) tempWorkingRegion.bottom.bounds.lastElement()).getFunc() == FunctionT.LINEAR) {
							BoundedFunction top = (BoundedFunction) tempWorkingRegion.top.bounds.lastElement();
							BoundedFunction bottom = (BoundedFunction) tempWorkingRegion.bottom.bounds.lastElement();
							
							Point bottomLeftPoint = new Point(bottom.leftX, bottom.evaluateAtPoint(bottom.leftX));
							Point topRightPoint = new Point(top.rightX, top.evaluateAtPoint(top.rightX));
							
							BoundedFunction newBottom = generateLineBetweenPoints(bottomLeftPoint, topRightPoint);
							tempWorkingRegion.bottom.bounds.remove(bottom);
							tempWorkingRegion.bottom.bounds.add(newBottom);
							
							tempWorkingRegion.right.bound = new PointBound(topRightPoint);
							regions.add(tempWorkingRegion);
						} else if (((BoundedFunction) tempWorkingRegion.top.bounds.lastElement()).getFunc() == FunctionT.PARABOLA) {
							BoundedFunction top = (BoundedFunction) tempWorkingRegion.top.bounds.lastElement();
							BoundedFunction bottom = (BoundedFunction) tempWorkingRegion.bottom.bounds.lastElement();
							
							Point leftPoint = new Point(top.leftX, top.evaluateAtPoint(top.leftX));
							Point rightPoint = new Point(bottom.rightX, bottom.evaluateAtPoint(bottom.rightX));
							
							double d = rightPoint.y - leftPoint.y;
							
							Point middlePoint = new Point ((leftPoint.x + rightPoint.x)/2, leftPoint.y + (d / 3));
							
							Point[] points = {leftPoint, middlePoint, rightPoint};
							
							String mathematicaOutput = new CasInterface().getLagrangePolynomial(points);
							//Will return null because parser needs to be finished.
							//BoundedFunction newTop = new CasInterface().parseLagrangePolynomial(mathematicaOutput);
							
							tempWorkingRegion.top.bounds.remove(top);
							//tempWorkingRegion.top.bounds.add(newTop);
							
							tempWorkingRegion.right.bound = new PointBound(rightPoint);
							regions.add(tempWorkingRegion);
						} else if (((BoundedFunction) tempWorkingRegion.bottom.bounds.lastElement()).getFunc() == FunctionT.PARABOLA) {
							//TODO: Implement Lagrange Polynomial interpolation for bottom function.
						}
					}
				}
			}
			else  //Else, keep constructing
			{
				regions = constructTopBottom(theTemplate, regions, tempWorkingRegion);
			}
		}
		
		//Remove all of those that are not similar to the template, ie, if not enough functions were generated.  
		/*for (Region region : regions) {
			if (region.top.bounds.size() != theTemplate.top.templateBounds.size() || 
				region.bottom.bounds.size() != theTemplate.bottom.templateBounds.size()) {
				regions.remove(region);
			}
		}*/
		return regions;
	}

	private boolean flipFunction(BoundedFunction function, Region tempWorkingRegion) {
		int attempts = 0;
		while (!satisfies(function, tempWorkingRegion.bottom.bounds) && attempts < MAX_ATTEMPTS) {
			function.a = -function.a;
			if (satisfies(function, tempWorkingRegion.bottom.bounds)) 
				break;

			function.a = -function.a;
			function.b = -function.b;
			if (satisfies(function, tempWorkingRegion.bottom.bounds)) 
				return true;

			function.a = -function.a;
			if (satisfies(function, tempWorkingRegion.bottom.bounds)) 
				return true;

			function.a = chooseRandomCoefficient(true);
			function.b = chooseRandomCoefficient(false);
			attempts++;
		}
		if (attempts >= Constants.MAX_ATTEMPTS) return false;  //Throw out this example.  Pretend we did not go down this route.
		return true;
	}
	
	//For choosing a random coefficient.  Boolean allows for changing of vertical and horizontal constraints but keeping the code the same
	private double chooseRandomCoefficient(boolean isA) {
		double a = 0;
		double b = 0;
		if (INTS_ONLY) {
			a = RandomGenerator.nextInt(1, Constants.MAX_VERTICAL_STRETCH * 2 )  - Constants.MAX_VERTICAL_STRETCH;
			b = RandomGenerator.nextInt(1, Constants.MAX_HORIZONTAL_STRETCH * 2 )  - Constants.MAX_HORIZONTAL_STRETCH;
		}
		else
		{
			int[] validDenominators = {1, 3, 4, 5}; //2 is absent because 2/4 can be simplified. I don't want repetition.
			int denominator = validDenominators[ RandomGenerator.nextInt(validDenominators.length) ];
			int numerator = RandomGenerator.nextInt(1, Constants.MAX_VERTICAL_STRETCH * 2 ) * denominator  - (Constants.MAX_HORIZONTAL_STRETCH / denominator);

			a = (double)numerator / denominator; 

			denominator = validDenominators[ RandomGenerator.nextInt(validDenominators.length) ];
			numerator = RandomGenerator.nextInt(1, Constants.MAX_HORIZONTAL_STRETCH * 2 ) * denominator  - (Constants.MAX_HORIZONTAL_STRETCH / denominator);

			b = (double)numerator / denominator;
		}
		if (a == 0) a = chooseRandomCoefficient(true);
		if (b == 0) b = chooseRandomCoefficient(false);
		return isA ? a : b;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Main method of generating a single function
	//Add the output to a Vector<Bound>, either top or bottom.
	private BoundedFunction generateFunction(boolean isBottom, Region workingRegion, FunctionT type) {
		double a = 0;
		double b = 0;

		a = chooseRandomCoefficient(true);
		b = chooseRandomCoefficient(false);

		//So we don't get too crazy.
		if (Constants.SIMPLE_COEFFICIENTS){
			switch (type) {
			case HORIZONTAL_LINE :
			case LINEAR :
			case PARABOLA :
			case CUBIC :
			case QUARTIC :
			case QUINTIC :
				b = 1; break;
			case SINE : 
			case COSINE :
				b = Math.PI; break;
			default:
				break;
			}
		}

		double h = 0;
		double k = 0;
		//Find h, k from the top/bottom bound.  If they are null, find it from the left bound. 
		try {
			Bound bound;
			if (isBottom)
				bound = workingRegion.bottom.bounds.lastElement();
			else
				bound = workingRegion.top.bounds.lastElement();
			
			if (bound.getBoundT() != Bound.BoundT.VERTICAL_LINE) {
				h = bound.getLeftBottomPoint().x; //Doesn't matter for functions, but does for line segments.
				k = bound.getLeftBottomPoint().y; //Doesn't matter for functions, but does for line segments.
			} else {
				Bound tempBound;
				if (isBottom)
					tempBound = workingRegion.bottom.bounds.get(workingRegion.bottom.bounds.size() - 2);
				else
					tempBound = workingRegion.top.bounds.get(workingRegion.top.bounds.size() - 2);
				
				if (tempBound.getLeftBottomPoint().equals(bound.getLeftBottomPoint())) {
					h = bound.getLeftTopPoint().x;
					k = bound.getLeftTopPoint().y;
				} else {
					h = bound.getLeftBottomPoint().x;
					k = bound.getLeftBottomPoint().y;
				}
			}
		} catch (Exception E) {
			if (isBottom){
				h = workingRegion.left.bound.getLeftBottomPoint().x;
				k = workingRegion.left.bound.getLeftBottomPoint().y;
			} else {
				h = workingRegion.left.bound.getLeftTopPoint().x;
				k = workingRegion.left.bound.getLeftTopPoint().y;
			}
		}
		
		//Left and right bounds.
		double leftX = 0;
		double rightX = 0;

		try {
			Bound bound;
			if (isBottom)
				bound = workingRegion.bottom.bounds.lastElement();
			else
				bound = workingRegion.top.bounds.lastElement();

			if (bound instanceof BoundedFunction)
				leftX = ((BoundedFunction)bound).getRightX();
			else { } //if bound is a vertical line, get the vertex not equal to the previous BoundedFunction at x

		} catch (Exception E) {          //If bound is null, 
			leftX = 0.0;
		}

		rightX = leftX + RandomGenerator.nextInt((int)MAX_RIGHT_X) + 1;

		if (!isBottom && SAME_LENGTH_BOUNDS)
			rightX = ((BoundedFunction)workingRegion.bottom.bounds.lastElement()).getRightX();

		return new BoundedFunction(type, a, b, h, k, leftX, rightX);
	}
	
	private BoundedFunction generateLineBetweenPoints(Point p1, Point p2) {
		double leftBound = p1.x, rightBound = p2.x;
		
		double b = 1;  //No need to get crazy here, or anything.
		
		double a = (p2.y - p1.y)/(p2.x - p1.x);
		
		double h = 0;
		
		double k = a * (- p2.x) + p2.y;
		
		return new BoundedFunction(FunctionT.LINEAR, a, b, h, k, leftBound, rightBound);
	} 


	//Checks to make sure the BoundedFunction does not intersect any of the bounds.
	public boolean satisfies(BoundedFunction f, Vector<Bound> bounds)
	{
		// An empty set by default satisfies the function
		if (bounds.isEmpty()) return true;

		//
		// Check in reverse to ensure the function satisfies each function in the bounds 
		//
		for (int index = bounds.size() - 1; index >= 0; index++)
		{
			//            if (bounds[index].intersects(f))
			//            {
			//                
			//            }
		}

		return true;
	}
}